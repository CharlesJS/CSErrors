//
//  POSIX Errors.swift
//  
//
//  Created by Charles Srstka on 1/10/23.
//

import System

#if canImport(Darwin)
import Darwin
func getErrno() -> Int32 { Darwin.errno }
#elseif canImport(Glibc)
import Glibc
func getErrno() -> Int32 { Glibc.errno }
#endif

internal var posixErrorDomain: String { "NSPOSIXErrorDomain" }

extension Error {
    public func toErrno() -> Int32? {
        if #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *), let err = self as? System.Errno {
            return err.rawValue
        }

        if let osStatusErr = self as? OSStatusError, let err = translateOSStatusToPOSIX(osStatusErr.rawValue) {
            return err
        }

        switch self._domain {
        case posixErrorDomain:
            return Int32(self._code)
        case OSStatusError.osStatusErrorDomain:
            return translateOSStatusToPOSIX(OSStatus(self._code))
        default: break
        }

        return nil
    }
}

/// Create an `Error` corresponding to a POSIX error code.
///
/// If `url` is provided, this method will wrap the resulting error in a `CocoaError`, if applicable.
/// - Parameters:
///     - code: A POSIX error code. Defaults to the POSIX global `errno` variable.
///     - path: An optional file path to associate with the error, if applicable.
///     - isWrite: Optional. Set to `true` if the error is known to have been generated by a write operation.
///         This parameter is ignored unless `url` is provided.
/// - Returns: An `Error` wrapping the POSIX error code.
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *)
public func errno(_ code: Int32? = nil, path: FilePath, isWrite: Bool = false) -> any Error {
    let code = code ?? getErrno()

    if let err = (posixConnector as? _CSErrorsPOSIXErrorInternal)?.translateErrno(code, path: path, isWrite: isWrite) {
        return err
    }

    if code == 0 {
        return GenericError.unknownError(isWrite: isWrite)
    }

    return System.Errno(rawValue: code)
}

/// Create an `Error` corresponding to a POSIX error code.
///
/// If `url` is provided, this method will wrap the resulting error in a `CocoaError`, if applicable.
/// - Parameters:
///     - code: A POSIX error code. Defaults to the POSIX global `errno` variable.
///     - path: An optional file path to associate with the error, if applicable.
///     - isWrite: Optional. Set to `true` if the error is known to have been generated by a write operation.
///         This parameter is ignored unless `url` is provided.
/// - Returns: An `Error` wrapping the POSIX error code.
public func errno(_ code: Int32? = nil, path: String? = nil, isWrite: Bool = false) -> any Error {
    let code = code ?? getErrno()

    if let err = (posixConnector as? _CSErrorsPOSIXErrorInternal)?.translateErrno(code, path: path, isWrite: isWrite) {
        return err
    }

    if code == 0 {
        return GenericError.unknownError(isWrite: isWrite)
    }

    guard #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *) else {
        return GenericError(_domain: "NSPOSIXErrorDomain", _code: Int(code))
    }

    return System.Errno(rawValue: code)
}

public enum POSIXReturnExpectation {
    case zero
    case nonNegative
    case specific(Int32)
}

public enum POSIXErrorReturn {
    case globalErrno
    case returnValue
}

@discardableResult
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *)
public func callPOSIXFunction<I: BinaryInteger>(
    expect: POSIXReturnExpectation,
    errorFrom: POSIXErrorReturn = .globalErrno,
    path: FilePath,
    isWrite: Bool = false,
    closure: () -> I
) throws -> I {
    let (ret, isError) = _callPOSIXFunction(expect: expect, errorFrom: errorFrom, closure: closure)

    if isError {
        throw errno(Int32(ret), path: path, isWrite: isWrite)
    }

    return ret
}

@discardableResult
public func callPOSIXFunction<I: BinaryInteger>(
    expect: POSIXReturnExpectation,
    errorFrom: POSIXErrorReturn = .globalErrno,
    path: String? = nil,
    isWrite: Bool = false,
    closure: () -> I
) throws -> I {
    let (ret, isError) = _callPOSIXFunction(expect: expect, errorFrom: errorFrom, closure: closure)

    if isError {
        throw errno(Int32(ret), path: path, isWrite: isWrite)
    }

    return ret
}

@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *)
public func callPOSIXFunction<T>(
    expect: POSIXReturnExpectation,
    errorFrom: POSIXErrorReturn = .globalErrno,
    path: FilePath,
    isWrite: Bool = false,
    closure: (UnsafeMutablePointer<T>) -> some BinaryInteger
) throws -> T {
    switch _callPOSIXFunction(expect: expect, errorFrom: errorFrom, closure: closure) {
    case .success(let returnValue):
        return returnValue
    case .failure(let err):
        throw errno(err, path: path, isWrite: isWrite)
    }
}

public func callPOSIXFunction<T>(
    expect: POSIXReturnExpectation,
    errorFrom: POSIXErrorReturn = .globalErrno,
    path: String? = nil,
    isWrite: Bool = false,
    closure: (UnsafeMutablePointer<T>) -> some BinaryInteger
) throws -> T {
    switch _callPOSIXFunction(expect: expect, errorFrom: errorFrom, closure: closure) {
    case .success(let returnValue):
        return returnValue
    case .failure(let err):
        throw errno(err, path: path, isWrite: isWrite)
    }
}

@_spi(CSErrorsInternal) public func _callPOSIXFunction<I: BinaryInteger>(
    expect: POSIXReturnExpectation,
    errorFrom: POSIXErrorReturn,
    closure: () -> I
) -> (I, Bool) {
    let returnValue = closure()
    let globalErrno = getErrno()
    let success: Bool

    switch expect {
    case .zero:
        success = returnValue == 0
    case .nonNegative:
        success = returnValue >= 0
    case .specific(let specificValue):
        success = returnValue == specificValue
    }

    if !success {
        switch errorFrom {
        case .globalErrno:
            return (I(globalErrno), true)
        case .returnValue:
            return (returnValue, true)
        }
    }

    return (returnValue, false)
}

private enum PointerReturn<T> {
    case success(T)
    case failure(Int32)
}
private func _callPOSIXFunction<T>(
    expect: POSIXReturnExpectation,
    errorFrom: POSIXErrorReturn,
    closure: (UnsafeMutablePointer<T>) -> some BinaryInteger
) -> PointerReturn<T> {
    let returnPointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
    defer { returnPointer.deallocate() }

    let ptrClosure = { closure(returnPointer) }

    let (err, isError) = _callPOSIXFunction(expect: expect, errorFrom: errorFrom, closure: ptrClosure)

    if isError {
        return .failure(Int32(err))
    }

    return .success(returnPointer.pointee)
}

@_spi(CSErrorsInternal) public struct POSIXConnector {}
private let posixConnector = POSIXConnector()

@_spi(CSErrorsInternal) public protocol _CSErrorsPOSIXErrorInternal {
    @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *)
    func translateErrno(_ code: Int32, path: FilePath, isWrite: Bool) -> any Error

    func translateErrno(_ code: Int32, path: String?, isWrite: Bool) -> any Error
}
