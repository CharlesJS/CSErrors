//
//  Utils.swift
//  CSErrors
//
//  Created by Charles Srstka on 4/17/20.
//  Copyright © 2020-2021 Charles Srstka. All rights reserved.
//

import Foundation

#if canImport(System)
import System
#endif

/**
 Create an `Error` corresponding to a POSIX error code. If `url` is provided, this method will wrap the resulting
 error in a `CocoaError`, if applicable.
 - Parameters:
     - code: A POSIX error code. Defaults to the POSIX global `errno` variable.
     - url: An optional `URL` to associate with the error, if applicable.
     - isWrite: Optional. Set to `true` if the error is known to have been generated by a write operation.
         This parameter is ignored unless `url` is provided.
 - Returns: An `Error` wrapping the POSIX error code.
 */
public func errno(_ code: Int32 = Foundation.errno, url: URL? = nil, isWrite: Bool = false) -> Error {
    if code == 0 {
        return CocoaError(.fileReadUnknown)
    } else if #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *) {
        let err = System.Errno(rawValue: code)

        if err.isCancelledError {
            return CocoaError(.userCancelled, underlying: err)
        }

        if let url = url, let cocoaCode = cocoaCode(errno: err, url: url, isWrite: isWrite) {
            return CocoaError(cocoaCode, url: url, underlying: err)
        }

        return err
    } else if let posixCode = POSIXErrorCode(rawValue: code) {
        let err = POSIXError(posixCode)

        if err.isCancelledError {
            return CocoaError(.userCancelled, underlying: err)
        }

        if let url = url, let cocoaCode = cocoaCode(posixCode: posixCode, url: url, isWrite: isWrite) {
            return CocoaError(cocoaCode, url: url, underlying: err)
        }

        return err
    } else {
        return NSError(domain: NSPOSIXErrorDomain, code: Int(code), userInfo: nil)
    }
}

@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, macCatalyst 14.0, *)
private func cocoaCode(errno: System.Errno, url: URL, isWrite: Bool) -> CocoaError.Code? {
    switch errno {
    case .permissionDenied, .notPermitted:
        return isWrite ? .fileWriteNoPermission : .fileReadNoPermission
    case .noSuchFileOrDirectory:
        return isWrite ? .fileNoSuchFile : .fileReadNoSuchFile
    case .fileExists:
        return .fileWriteFileExists
    case .fileTooLarge:
        return .fileReadTooLarge
    case .noSpace:
        return .fileWriteOutOfSpace
    case .readOnlyFileSystem:
        return .fileWriteVolumeReadOnly
    case .badFileTypeOrFormat:
        return .fileReadCorruptFile
    case .canceled:
        return .userCancelled
    default:
        return nil
    }
}

private func cocoaCode(posixCode: POSIXError.Code, url: URL, isWrite: Bool) -> CocoaError.Code? {
    switch posixCode {
    case .EPERM, .EACCES:
        return isWrite ? .fileWriteNoPermission : .fileReadNoPermission
    case .ENOENT:
        return isWrite ? .fileNoSuchFile : .fileReadNoSuchFile
    case .EEXIST:
        return .fileWriteFileExists
    case .EFBIG:
        return .fileReadTooLarge
    case .ENOSPC:
        return .fileWriteOutOfSpace
    case .EROFS:
        return .fileWriteVolumeReadOnly
    case .EFTYPE:
        return .fileReadCorruptFile
    case .ECANCELED:
        return .userCancelled
    default:
        return nil
    }
}

/**
 Create an `Error` from an `OSStatus`.
 - Parameters:
     - osStatus: The `OSStatus` error code to convert to an `Error`.
     - description: A localized message describing what error occurred.
         Corresponds to `NSLocalizedDescriptionKey` in the `userInfo` dictionary.
         If provided, this value will be returned by the `localizedDescription` method.
     - failureReason: A localized message describing the reason for the failure.
         Corresponds to `NSLocalizedFailureReasonErrorKey` in the `userInfo` dictionary.
         If no value is provided for `description`, this value will be returned by the `localizedDescription`
         method.
     - recoverySuggestion: A localized message describing how one might recover from the failure.
         Corresponds to `NSLocalizedRecoverySuggestionErrorKey` in the `userInfo` dictionary.
     - recoveryOptions: A localized message providing “help” text if the user requests help.
         Corresponds to `NSLocalizedRecoveryOptionsErrorKey` in the `userInfo` dictionary.
     - recoveryAttempter: An object that conforms to the `NSErrorRecoveryAttempting` informal protocol.
         Corresponds to `NSRecoveryAttempterErrorKey` in the `userInfo` dictionary.
     - helpAnchor: A string to display in response to an alert panel help anchor button being pressed.
         Corresponds to `NSHelpAnchorErrorKey` in the `userInfo` dictionary.
     - stringEncoding: The string encoding associated with this error, if any.
         Corresponds to `NSStringEncodingErrorKey` in the `userInfo` dictionary.
     - url: A URL associated with the error. Corresponds to `NSURLErrorKey` in the `userInfo` dictionary.
         If the URL is a `file:` URL, this also sets `NSFilePathErrorKey` in the `userInfo` dictionary,
         which is very useful for customizing the  error's `localizedDescription` based on the associated filename.
     - underlying: The underlying error which caused this error, if any. Corresponds to `NSUnderlyingErrorKey`
         in the `userInfo` dictionary.
     - custom: A dictionary containing additional key-value pairs to insert in the `userInfo` dictionary.
 - Returns: An `Error` representing the `OSStatus`.
 */
public func OSStatusError(
    _ osStatus: OSStatus,
    description: String? = nil,
    recoverySuggestion: String? = nil,
    recoveryOptions: [String]? = nil,
    recoveryAttempter: Any? = nil,
    helpAnchor: String? = nil,
    stringEncoding: String.Encoding? = nil,
    url: URL? = nil,
    underlying: Error? = nil,
    custom: [String: Any]? = nil
) -> Error {
    var userInfo = makeErrorUserInfo(
        description: description,
        recoverySuggestion: recoverySuggestion,
        recoveryOptions: recoveryOptions,
        recoveryAttempter: recoveryAttempter,
        helpAnchor: helpAnchor,
        stringEncoding: stringEncoding,
        url: url,
        underlying: underlying,
        custom: custom
    )

    if (kPOSIXErrorBase..<(kPOSIXErrorBase + 1000)).contains(Int(osStatus)) {
        return errno(osStatus - Int32(kPOSIXErrorBase))
    } else if let errMsg = SecCopyErrorMessageString(osStatus, nil) {
        userInfo[NSLocalizedFailureReasonErrorKey] = "\(errMsg) (\(osStatus))"
    }

    return NSError(domain: NSOSStatusErrorDomain, code: Int(osStatus), userInfo: userInfo)
}

/**
 A helper for quickly making `userInfo` dictionaries.
 This can be very useful when implementing the `CustomNSError` protocol, and for associating data with other
 error classes that take `userInfo` dictionaries (such as `CocoaError`).
 
 - Parameters:
     - description: A localized message describing what error occurred.
         Corresponds to `NSLocalizedDescriptionKey` in the `userInfo` dictionary.
         If provided, this value will be returned by the `localizedDescription` method.
     - failureReason: A localized message describing the reason for the failure.
         Corresponds to `NSLocalizedFailureReasonErrorKey` in the `userInfo` dictionary.
         If no value is provided for `description`, this value will be returned by the `localizedDescription`
         method.
     - recoverySuggestion: A localized message describing how one might recover from the failure.
         Corresponds to `NSLocalizedRecoverySuggestionErrorKey` in the `userInfo` dictionary.
     - recoveryOptions: A localized message providing “help” text if the user requests help.
         Corresponds to `NSLocalizedRecoveryOptionsErrorKey` in the `userInfo` dictionary.
     - recoveryAttempter: An object that conforms to the `NSErrorRecoveryAttempting` informal protocol.
         Corresponds to `NSRecoveryAttempterErrorKey` in the `userInfo` dictionary.
     - helpAnchor: A string to display in response to an alert panel help anchor button being pressed.
         Corresponds to `NSHelpAnchorErrorKey` in the `userInfo` dictionary.
     - stringEncoding: The string encoding associated with this error, if any.
         Corresponds to `NSStringEncodingErrorKey` in the `userInfo` dictionary.
     - url: A URL associated with the error. Corresponds to `NSURLErrorKey` in the `userInfo` dictionary.
         If the URL is a `file:` URL, this also sets `NSFilePathErrorKey` in the `userInfo` dictionary,
         which is very useful for customizing the display of `CocoaError` errors and other errors which customize
         their `localizedDescription` based on the associated filename.
     - underlying: The underlying error which caused this error, if any. Corresponds to `NSUnderlyingErrorKey`
         in the `userInfo` dictionary.
     - custom: A dictionary containing additional key-value pairs to insert in the `userInfo` dictionary.
 - Returns: A `userInfo` dictionary, suitable for implementing `CustomNSError`'s `userInfo` property.
 */
public func makeErrorUserInfo( // swiftlint:disable:this cyclomatic_complexity
    description: String? = nil,
    failureReason: String? = nil,
    recoverySuggestion: String? = nil,
    recoveryOptions: [String]? = nil,
    recoveryAttempter: Any? = nil,
    helpAnchor: String? = nil,
    stringEncoding: String.Encoding? = nil,
    url: URL? = nil,
    underlying: Error? = nil,
    custom: [String: Any]? = nil) -> [String: Any] {

    var userInfo = [String: Any]()

    if let desc = description {
        userInfo[NSLocalizedDescriptionKey] = desc
    } else if let failureReason = failureReason {
        userInfo[NSLocalizedDescriptionKey] = failureReason
    }

    if let failureReason = failureReason {
        userInfo[NSLocalizedFailureReasonErrorKey] = failureReason
    }

    if let suggestion = recoverySuggestion {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion
    }

    if let options = recoveryOptions {
        userInfo[NSLocalizedRecoveryOptionsErrorKey] = options
    }

    if let attempter = recoveryAttempter {
        userInfo[NSRecoveryAttempterErrorKey] = attempter
    }

    if let anchor = helpAnchor {
        userInfo[NSHelpAnchorErrorKey] = anchor
    }

    if let encoding = stringEncoding {
        userInfo[NSStringEncodingErrorKey] = NSNumber(value: encoding.rawValue)
    }

    if let underlying = underlying {
        userInfo[NSUnderlyingErrorKey] = underlying
    }

    if let url = url {
        userInfo[NSURLErrorKey] = url

        if url.isFileURL {
            userInfo[NSFilePathErrorKey] = url.path
        }
    }

    if let custom = custom {
        for (key, value) in custom {
            userInfo[key] = value
        }
    }

    return userInfo
}
